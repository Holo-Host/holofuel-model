#+TITLE: Holo Fuel Model
#+STARTUP: org-startup-with-inline-images inlineimages
#+OPTIONS: ^:nil # Disable sub/superscripting with bare _; _{...} still works
#+LATEX_HEADER: \usepackage[margin=1.0in]{geometry}
* Holo Fuel Valuation

  A value-stable wealth-backed cryptocurrency platform, where each unit is defined in terms of a
  basked of computational resources, operating in a powerful decentralized verification environment.

   #+BEGIN_SRC ditaa :file images/holofuel-overview.png :cmdline -r -S -o

       +-----------------------------------------+
       |                                         |
       v                                         |
   +--------+               +--------+           | 
   |        |               |        |           | 
   |        |-+  Something  | PID    | Whatever  |
   |        + |------------>|        |-----------+
   +--------+ |  X Mbps     +--------+  Y Mbps    
     |        |                                   
     +--------+                                   
       account


   #+END_SRC

   #+RESULTS[e258c96572d9aa87fbfc86914918be06b93ab951]:
   [[file:images/holofuel-overview.png]]

** The Computational Resources Basket

   One Holo Fuel (HOT) is defined as being able to purchase 1 month of Holo Hosting services for the
   front-end (ie. web API, databases, etc.) portion of a typical dApp.

   This might be roughly equivalent to the 2018 price of (and actual utilization of) a small cloud
   hosting setup (eg. several $5/month Droplet on Digital Ocean at partial utilization hosting
   front-ends, DBs, backups, etc.), plus ancillary hosting services (represented by a premium for
   inclusion in the Holo system).

   If the minimal Hosting costs for a small Web app is estimated at USD$100/mo., and comprises 5
   cloud hosting nodes and anciliary services for the various aspects of the system.  An equivalent
   Holo Host based system would have similar CPU and storage requirements overall, but a greater
   redundancy (say, 5 x, so all DHTs spread across 25 Holo Hosts).

   Thus, the basket of commodities defining the value of USD$100 =~= 100 Holo Fuel could be defined as:

   #+LATEX: {\scriptsize
   #+BEGIN_SRC ipython :session :exports results :results raw drawer

     %matplotlib inline
     %config InlineBackend.figure_format = 'retina'

     from __future__ import absolute_import, print_function, division
     try:
         from future_builtins import zip, map # Use Python 3 "lazy" zip, map
     except ImportError:
            pass

     import matplotlib
     import matplotlib.pyplot as plt
     plt.rcParams["figure.figsize"]     = (5,2)
     plt.rcParams["font.size"]          = 6
     import numpy as np
     from sklearn import linear_model
     import collections
     import math

     # For more info about emacs + ob-ipython integration, see: https://github.com/gregsexton/ob-ipython

     # Each commodity underlying the currency's price basket must be priced in standardized Units, of a
     # specified quality, FOB some market.  The Holo Fuel basket's commodities are measured accross the
     # Holo system, and the Median resource is used; this allows the basket to evolve over time, as
     # Moore's law reduces the cost of the resource, the Median unit of that resource will likely
     # increase (eg. CPU cores), counterbalancing the natural deflationary tendency of tech prices.

     commodity_t             = collections.namedtuple(
         'Commodity', [
             'units',
             'quality',
             'notes',
         ] )
     commodities             = {
         'holo':         commodity_t( "Host",    "",           "Inclusion in the Holo system" ),
         'cpu':          commodity_t( "Core",    "Median",     "A processing core" ),
         'ram':          commodity_t( "GB",      "Median",     "Processor memory" ),
         'net':          commodity_t( "TB",      "Median",     "Internet bandwidth" ),
         'data':         commodity_t( "TB",      "Median",     "Persistent storage (DHT/DB/file)" ),
     }

     # The basket represents the computational resource needs of a typical Holochain dApp's "interface"
     # Zome.  A small dual-core Holo Host (ie. on a home Internet connection) could perhaps expect to run
     # 200 Holo Fuel worth of these at full CPU utilization, 1TB of bandwidth; a quad-core / 8-thread
     # perhaps 500 Holo Fuel worth at ~60% CPU (thread) utilization.

     iron_count              =   5                   # Real iron req'd to host tradition small App
     holo_fanout             =   5                   #   and additional Holo fan-out for DHT redundancy, etc.
     hosts                   = iron_count * holo_fanout
     basket_target           = 100.0                 # 1 Holo Fuel =~= 1 USD$; USD$100 of cloud hosting per minimal dApp, typ.
     basket                  = {
         # Commodity     Amount, Proportion
         'holo':        hosts,           # Holo Host system fan-out and value premium
         'cpu':          1.00,           # Cores, avg. utilization across all iron
         'ram':          1.00,           # GB,    ''
         'net':          0.50,           # TB,    '' 
         'data':         0.25,           # TB,    ''
     }

     # In the wild, prices will fluctuate according to supply/demand and money supply dynamics.  We'll
     # start with some artificial weights; some commodities cost more than others, so the same "units"
     # worth carry different weight in the currency basket.

     weight                  = {
         'holo':        60/100,
         'cpu':          5/100,
         'ram':          5/100,
         'net':         20/100,
         'data':        10/100,
     }             

     # Produces the org-mode table from result 2d list
     [ ["Commodity", "Amount", "Units", "Weight", "Description"],
       None ] \
     + [ [ k, "%5.2f" % basket[k], commodities[k].units, "%5.3f%%" % ( weight[k] * 100 ),
           commodities[k].notes ] for k in basket ]

   #+END_SRC

   #+RESULTS:
   :RESULTS:
   | Commodity | Amount | Units |  Weight | Description                      |
   |-----------+--------+-------+---------+----------------------------------|
   | holo      |  25.00 | Host  | 60.000% | Inclusion in the Holo system     |
   | net       |   0.50 | TB    | 20.000% | Internet bandwidth               |
   | ram       |   1.00 | GB    |  5.000% | Processor memory                 |
   | data      |   0.25 | TB    | 10.000% | Persistent storage (DHT/DB/file) |
   | cpu       |   1.00 | Core  |  5.000% | A processing core                |
   :END:

   #+LATEX: }

*** Holo Hosting Premium

    A Holochain Distributed Application (dApp) hosted on Holo provides a valuable set of features,
    over and above simply hosting a typical web application on a set of cloud servers.  These
    services must usually be either purchased, or architected by hand and distributed across
    multiple cloud hosting nodes for redundancy.

    - [ ] Reliability. Few single points of failure.
    - [ ] Backup. All DHT data is spread across many nodes.
    - [ ] Scalability.  Automatically scales to absorb increased load.

    The value of Holo is substantial in terms of real costs to traditional app developers, and is a
    component of the basket of commodities defining the price of Holo Fuel.  However, it's real
    monetary value will emerge over time, as the developer community comprehends it.  Our pricing
    algoritm must be able to dig this Holo premium component out of the historical hosting prices,
    as a separate component.

*** Resource Price Stability

    There are many detailed requirements for each of these commodities, which may be required for
    certain Holochain applications; CPU flags (eg. AVX-512, cache size, ...), RAM (GB/s bandwidth),
    HDD (time to first byte, random/sequential I/O bandwidth), Internet (bandwidth/latency to
    various Internet backbone routers). 

    The relative distribution of these features will change over time; RAM becomes faster, CPU cores
    more powerful. The definition of a typical unit of these commodities therefore changes; as
    Moore's law decreases the price, the specifications of the typical computer also improve,
    counterbalancing this inflationary trend.

    For each metric, the price of service on the median Holo Host node will be used; 1/2 will be
    below (weaker, priced at a discount), 1/2 above (more powerful, priced at a premium).  This will
    nullify the natural inflationary nature of Holo Fuel, if we simply defined it in terms of fixed
    2018 computational resources.

** Commodity Price Discovery

   Value stabilization requires knowledge of the current prices of each commodity in the currency's
   valuation basket, ideally denominated in the currency itself.  If these commodities are traded
   within the cryptocurrency implementation, then we can directly discover them on a distributed
   basis.  If outside commodity prices are used, then each independent actor computing the control
   loop must either reach consensus on the price history (as collected from external sources, such
   as Distributed Oracles), or trust a separate module to do so. In Holo Fuel, we host the sale of
   Holo Host services to dApp owners, so we know the historical prices.

   When a history of Holo Hosting service prices is available, Linear Regression can be used to
   discover the average fixed (Holo Hosting premium) and variable (CPU, ...) component costs
   included in the prices, and therefore the current commodity basket price.
   
*** Recovering Commodity Basket Costs

    To illustrate price recovery, lets begin with simulated prices of a basket of commodities.  A
    prototypical minimal dApp owner could select 100 Holo Fuel worth of these resources, eg. 25x
    Holo Hosts, .05 TB data, 1.5 cpu, etc. as appropriate for their specific application's needs.
    
    This Hosting selection wouldn't actually be a manual procedure; testing would indicate the kind
    of loads to expect for a given amount and type of user activity, and a calculator would estimate
    the various resource utilization and costs. At run time, the credit extended to the dApp owner
    (calculated from prior history of Hosting receipt payments) would set the maximum outstanding
    Hosting receipts allowed; the dApp deployment would auto-scale out to qualified Hosts in various
    tranches as required; candidate Hosts (hoping to generate Hosting receipts) would auto-install
    the application as it reached its limits of various resource utilization metrics across its
    current stable of Hosts.
    
    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports both :results value raw drawer

      def rnd_std_dst( sigma, mean=0, minimum=None ):
          """ """
          val                 = sigma * np.random.randn() + mean
          return val if minimum is None else max( minimum, val )

      # To simulate initial pricing, lets start with an estimate of proportion of basket value represented
      # by each amount of the basket's commodities.  Prices of each of these commodities is free to float
      # in a real market, but we'll start with some pre-determined "weights"; indicating that the amount
      # of the specified commodity holds a greater or lesser proportion of the basket's value.
      # Regardless, 100 Holo Fuel is guaranteed to buy the entire basket.
      prices                  = {}
      for k in basket:
          price_mean          = basket_target * weight[k] / basket[k] # target price: 1 Holo Fuel == 1 basket / basket_target
          price_sigma         = price_mean / 10 #  difference allowed; about +/- 10% of target
          prices[k]           = rnd_std_dst( price_sigma, price_mean )

      [ [ "Commodity", "Price", "Per", "Per" ],
        None ] \
      + [ [ k, "%5.2f" % ( prices[k] ), commodities[k].units, 'mo.' ]
          for k in basket ]

    #+END_SRC

    #+RESULTS:
    :RESULTS:
    | Commodity | Price | Per  | Per |
    |-----------+-------+------+-----|
    | holo      |  2.38 | Host | mo. |
    | net       | 44.67 | TB   | mo. |
    | ram       |  4.70 | GB   | mo. |
    | data      | 45.99 | TB   | mo. |
    | cpu       |  4.66 | Core | mo. |
    :END:

    #+LATEX: }

    From this set of current assumed commodity prices, we can compute the current price of the Holo
    Fuel currency's basket:

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports both :results value raw drawer

      basket_price            = sum( basket[k] * prices[k] for k in basket )
      [ [ "Holo Fuel Basket Price" ],
        None,
        [ "$%5.2f / %.2f" % ( basket_price, basket_target ) ] ]

    #+END_SRC

    #+RESULTS:
    :RESULTS:
    | Holo Fuel Basket Price |
    |------------------------|
    | $102.78 / 100.00       |
    :END:

    #+LATEX: }

    If the current price of this basket is >100, then we are experiencing commodity price inflation;
    if <100, price deflation.  Feedback control loops will act to bring the price back to 100 Holo Fuel
    per basket.

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :file images/basket-pie.png :exports both

      labels                  = [ k for k in basket ]
      sizes                   = [ basket[k] * prices[k] for k in basket ]
      explode                 = [ .1 if k == 'holo' else 0 for k in basket ]
      # with plt.xkcd():
      fig1,ax1        = plt.subplots()
      ax1.pie( sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90 )
      ax1.axis( 'equal' ) # Equal aspect ratio ensures that pie is drawn as a circle.
      plt.title( "%6.2f Holo Fuel Basket Price: %6.2f: %sflation" % (
                  basket_target, basket_price, "in" if basket_price > basket_target else "de" ))
      plt.show()

    #+END_SRC

    #+RESULTS:
    [[file:images/basket-pie.png]]

    #+LATEX: }

*** Holo Hosting Receipts 

    Once we have the currency's underlying commodity basket, lets simulate a sequence of trades of
    various amounts of these commodities.  In the Holo system, this is represented by Hosts issuing
    receipts for services to dApp owners.

    Each Hosting receipt will be for a single Holo Host, not for the entire dApp; the sum of all
    Holo Hosting receipts issued to the dApp owner for our archetypical small dApp would sum to
    approximately 100 Holo Fuel per month.

    We will not know the exact costs of each commodity used to compute the price, or how much is the
    baseline Holo system premium.  However, it will be dependant on the capability of the Host
    (stronger hosts can charge more, for hosting more specialized dApps), and the amount of various
    services used.

    So, lets issue a bunch of small Holo Hosting receipts, each for approximately 1/25th of the
    total Holo Hosting load (since our small dApp is spread across 25 Holo Hosts).

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports both :results value raw drawer

      amounts_mean            = 1.00
      amounts_sigma           = 0.5
      error_sigma             = 0.10 # +/- 10% variance in bids (error) vs. price
      trades                  = []
      number                  = 10000
      for _ in range( number ):
          # Each dApp consumes a random standard distribution of the target amount of each commodity
          amounts             = { k: 1 if k == 'holo'
                                     else basket[k] * rnd_std_dst( amounts_sigma, amounts_mean, minimum=0 ) / basket['holo']
                                  for k in basket }
          price               = sum( amounts[k] * prices[k] for k in amounts )
          error               = price * rnd_std_dst( error_sigma )
          bid                 = price + error
          trades.append( dict( bid = bid, price = price, error = error, amounts = amounts ))

      [ [ "Fuel","calc/err", "dApp Requirements" ], None ] \
      + [ [ 
            "%5.2f" % t['bid'],
            "%5.2f%+5.2f" % ( t['price'], t['error'] ),
             ", ".join( "%5.4f %s %s" % ( v, k, commodities[k].units ) for k,v in t['amounts'].items() ),
          ]
          for t in trades[:5] ] \
      + [ [ '...' ] ]

    #+END_SRC

    #+RESULTS:
    :RESULTS:
    | Fuel |  calc/err | dApp Requirements                                                               |
    |------+-----------+---------------------------------------------------------------------------------|
    | 3.98 | 4.19-0.21 | 1.0000 holo Host, 0.0221 net TB, 0.0000 ram GB, 0.0075 data TB, 0.1034 cpu Core |
    | 3.63 | 4.14-0.51 | 1.0000 holo Host, 0.0211 net TB, 0.0450 ram GB, 0.0088 data TB, 0.0431 cpu Core |
    | 3.56 | 3.74-0.17 | 1.0000 holo Host, 0.0117 net TB, 0.0441 ram GB, 0.0111 data TB, 0.0238 cpu Core |
    | 4.41 | 4.25+0.16 | 1.0000 holo Host, 0.0120 net TB, 0.0562 ram GB, 0.0183 data TB, 0.0476 cpu Core |
    | 4.59 | 4.03+0.56 | 1.0000 holo Host, 0.0157 net TB, 0.0348 ram GB, 0.0144 data TB, 0.0249 cpu Core |
    |  ... |           |                                                                                 |
    :END:
    #+LATEX: }

*** Recovery of Commodity Valuations

    Lets see if we can recover the approximate Holo baseline and per-commodity costs from a sequence
    of trades.  Create some trades of 1 x Holo + random amounts of commodities around the
    requirements of a typical Holo dApp, adjusted by a random amount (ie. 'holo' always equals 1
    unit, so that all non-varying remainder is ascribed to the "baseline" Holo Hosting premium).

    Compute a linear regression over the trades, to try to recover an estimate of the prices.

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports both :results value raw drawer

      items                   = [ [ t['amounts'][k] for k in basket ] for t in trades ]
      bids                    = [ t['bid'] for t in trades ]

      regression              = linear_model.LinearRegression( fit_intercept=False, normalize=False )
      regression.fit( items, bids )
      select                  = { k: [ int( k == k2 ) for k2 in basket ] for k in basket }
      predict                 = { k: regression.predict( select[k] ) for k in basket }

      [ [ "Score(R^2): ", "%.9r" % ( regression.score( items, bids )), '', '' ],
        None ] \
      + [ [ "Commodity",  "Predicted", "Actual", "Error",
            # "selected"
        ],
        None ] \
      + [ [ k, 
            "%5.2f" % ( predict[k] ),
            "%5.2f" % ( prices[k] ),
            "%+5.3f%%" % (( predict[k] - prices[k] ) * 100 / prices[k] ),
            #select[k]
          ]
          for k in basket ]

    #+END_SRC

    #+RESULTS:
    :RESULTS:
    | Score(R^2): | 0.5979783 |        |         |
    |-------------+-----------+--------+---------|
    | Commodity   | Predicted | Actual |   Error |
    |-------------+-----------+--------+---------|
    | holo        |      2.40 |   2.38 | +0.511% |
    | net         |     44.82 |  44.67 | +0.325% |
    | ram         |      4.75 |   4.70 | +1.031% |
    | data        |     44.52 |  45.99 | -3.202% |
    | cpu         |      4.59 |   4.66 | -1.485% |
    :END:

    #+LATEX: }

*** Commodity Basket Valuation

    Finally, we can estimate the current Holo Fuel basket price from the recovered commodity prices.

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports both :results value raw drawer

      basket_predict          = sum( basket[k] * predict[k]  for k in basket )
      [ [ "Holo Fuel Price Recovered", "vs. Actual", "Error" ], None,
        [ "$%5.2f / %.2f" % ( basket_predict, basket_target ), 
          "%5.2f" % ( basket_price ), 
          "%+5.3f%%" % (( basket_predict - basket_price ) * 100 / basket_price ),
          ]]

    #+END_SRC

    #+RESULTS:
    :RESULTS:
    | Holo Fuel Price Recovered | vs. Actual |   Error |
    |---------------------------+------------+---------|
    | $102.77 / 100.00          |     102.78 | -0.012% |
    :END:

    #+LATEX: }

    We have shown that we should be able to recover the underlying commodity prices, and hence the
    basket price with a high degree of certainty, even in the face of relatively large differences
    in the mix of prices paid for hosting.

** Simple Value Stability Control via PID

   The simplest implementation of value-stability is to directly control the credit supply.  Lets
   establish a simple wealth-backed monetary system with a certain amount of wealth attached to it,
   from which we extend credit at a factor =K= of 0.5 to begin with; half of the value of the wealth is
   available in credit.  Adjusting =K= increases/reduces the liquid credit supply.

   The economy has a certain stock of Host resources available (eg. cpu, net, ...), and a certain
   pool of dApp owners wanting to buy various combinations of them.  The owners willing to pay more
   will get preferred access to the resources. In a traditional bid/ask market, greater bids are
   satisfied first, lesser later or not at all. In Holo, tranches of similar Hosts round-robin
   requests from clients of the dApps they host.

*** Host/dApp Pricing

    In the Holo Host environments, Hosts are pooled in tranches of like resource capacity (eg. cpu:
    type, count, ...), quality (eg. service: availability, longevity, ...), and price
    (eg. autopilot/manual pricing: lolo, lo, median, hi, hihi).  A multi-dimensional table of Host
    tranches is maintained; each Host inserts itself into the correct table.

    - TODO: How do the DHT peers confirm that a Host isn't lying about its internal computational
      resources?  A dApp could check, and issue a warrant if the Host is lying, but a DHT peer
      couldn't independently verify these claims.  There will be great incentive to inflate claims,
      to draw and serve higher-priced requests...)
   
    A dApp owner also selects the resource requirements (eg. cpu: avx-128+, 4+ cores, ...) service
    level and pricing (eg. median).
   
    Requests from hihi priced dApps are distributed first to the lolo, then lo, ..., hihi tranches
    of Hosts, as each tranche's resources is saturated; thus, lolo priced Hosts are saturated first.
    Then, hi dApps are served any by lolo, lo, ...  Hosts not yet saturated, and so on.  Thus, in
    times of low utilization (less dApps than Hosts), the highest priced Hosts may remain idle; in
    high utilization (more dApps than Hosts), the lowest priced dApp's requests may remain unserved
    (or, perhaps throttled and served round-robin, to avoid complete starvation of the lower priced
    dApp groups). Of course, these tranches of Hosts are also limited (via a set Union) to those
    Hosts in each tranche that *also* host a given target dApp, and requests for a dApp are only
    sent to those hosts who can service it.

    - TODO: Each TCP/IP HTTP socket, representing 1 or more HTTP requests or a WebSocket initiation,
      is assigned a Host; does Holo terminate the connection and relay I/O to/from the Host? It
      should pre-establish a pool of sockets to candidate Hosts, ready to be distributed to incoming
      requests, thus eliminating the delay of the 3-way handshake, and pre-eliminating
      dead/unreachable Hosts.) This requires a persistent proxy a.la. Cloudflare. Much more simply,
      perhaps, we could build [[https://insights.sei.cmu.edu/sei_blog/2017/02/six-best-practices-for-securing-a-robust-domain-name-system-dns-infrastructure.html][DNS servers]] that advertise multiple A records from an appropriate
      tranche of candidate servers, in round-robin fashion, and let the end-user sort out servers
      that disappear (until the DNS server figures out they're dead and stops serving their IP
      address).  However, intervening caching DNS servers (eg. at large ISPs) could conduit large
      numbers of request (ie. from the entire ISP!) to those few Host A-records for the
      time-to-live of the cached DNS query.

*** Host/dApp Pricing Automation Approaches

    How does the system compute the actual price that "median" Hosts get paid?  How does it evolve
    over time?  1/2 of requests should go to median, lo, lolo Hosts, and 1/2 should go to median,
    hi, hihi Hosts.  A PID loop could move the "Median" Host price to make this true, perhaps.
    Hosts should set a minimum average price they'll earn, dApps a maximum average price they're
    willing to pay, and their requests are throttled to only the Host tranches which satisfy these
    limits.

    By automatically switching a Host to higher/lower pricing tiers, and the dApp to lower/higher
    pricing selections, as their limit prices are reached, the numbers of Hosts/dApps above/below
    "median" changes -- and the PID loop adjusts the median price to achieve above/below
    equilibrium.  Thus, as more dApps exceed their high limit, switch to lower tiers (eg. from hi
    --> median --> lo), the mix of requests above/below median price changes, and the PID loop
    responds by adjusting the median Hosting price, which affects average dApp request pricing,
    which causes the dApp to hit its limits, which causes it to (again) switch to a lower tier...

    Of course, the dApp owner is informed of this, in real time, and can make price limit
    adjustments, to re-establish dApp performance.  Likewise, a Hosting owner can see that their
    Hosts are saturated/idle, and increase/decrease their minimum price, or maximum utilization
    targets; the Host should increase its desired pricing tier, to stay under its maximum
    utilization target.

*** Simple Host/dApp Pricing Model

    For the purposes of this simple test, we'll assume that the Host will simply spend all the
    credit the dApp has available serving its requests (we won't simulate the dApps).  So, lets
    generate a sequence of request service receipts from the Host to dApp owners, tuned to the
    credit available to the dApp.

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports both :results value raw drawer

      class credit_static( object ):
          """Simplest, static K-value, unchanging basket and prices."""
          def __init__( self, K, basket, prices ):
              self.K          = K
              self.basket     = dict( basket )
              self.prices     = dict( prices )

          def value( self, prices=None, basket=None ):
              """Compute the value of a basket at some prices (default: self.basket/prices)"""
              if prices is None: prices = self.prices
              if basket is None: basket = self.basket
              return sum( prices[k] * basket[k] for k in basket )

      # Adjust this so that our process value 'basket_value' achieves setpoint 'basket_target'
      # Use the global basket, prices defined above
      credit                  = credit_static( K=0.5, basket=basket, prices=prices )

      #print( "Global basket: %r, prices: %r" % ( basket, prices ))
      #print( "credit.basket: %r, prices: %r" % ( credit.basket, credit.prices ))

      duration_hour           = 60 * 60
      duration_day            = 24 * duration_hour
      duration_month          = 365.25 * duration_day / 12 # 2,629,800s.

      used_mean               = 1.0                   # Hourly usage is 
      used_sigma              = used_mean * .10       # +/-10% 
      reqs_mean               = 2.0                   # Avg. Host is 2x minimal
      reqs_sigma              = reqs_mean * .5        # +/- 50%
      reqs_min                = 1/10                  #   but at least this much of minimal dApp
      class dApp( object ):
          def __init__( self, duration=duration_month ): # 1 mo., in seconds
              """Select a random basket of computational requirements, some multiple of the minimal dApp
              represented by the Holo Fuel basket (min. 10% of basket), for the specified duration."""
              self.duration   = duration
              self.requires   = { k: rnd_std_dst( sigma=reqs_sigma, mean=reqs_mean, minimum=reqs_min ) \
                                       * credit.basket[k] * duration / duration_month
                                   for k in credit.basket }
              # Finally, compute the wealth required to fund this at current credit factor K
              self.wealth      = credit.value( basket=self.requires ) / credit.K
              #print( repr( self ))

          def __repr__( self ):
              return "<dApp using %8.2f Holo Fuel / %5.2f mo.: %s" % (
                         credit.value( basket=self.requires ), self.duration/duration_month,
                         ", ".join( "%6.2f %s %s" % ( self.requires[k] * self.duration/duration_month,
                                                     commodities[k].units, k ) for k in credit.basket ))

          def available( self, dt=None ):
              """Credit available for dt seconds (1 hr., default) of Hosting."""
              return self.wealth * credit.K * ( dt or duration_hour ) / self.duration

          def used( self, dt=None, mean=1.0, sigma=.1 ):
              """Resources used over period dt (+/- 10% default, but at least 0)"""
              return { k: self.requires[k] * rnd_std_dst( sigma=sigma, mean=mean, minimum=0 ) * dt / self.duration
                       for k in self.requires }

      class Host( object ):
          def __init__( self, dApp ):
              self.dApp       = dApp

          def receipt( self, dt=None ):
              """Generate receipt for dt seconds worth of hosting our dApp; spend all available credit.  This
              could be acheived, for example, by selecting a lower pricing teir (thus worse performance)."""
              avail           = self.dApp.available( dt=dt )                # Credit available
              used            = self.dApp.used( dt=dt, sigma=used_sigma )   # Roughly what hosting resources would be used
              value           = credit.value( basket=used )                 # total value of dApp Hosting resources used
              #print( "avail: {}, value: {}, used: {}".format( avail, value, used ))
              return avail,used

      hosts_count             = 60 * 60 # ~1 Hosting receipt per second
      hosts                   = [ Host( dApp() ) for _ in range( hosts_count ) ]
      hours_count             = 24

      class credit_sine( credit_static ):
          def __init__( self, amp, step, **kwds ):
              self.sine_amp   = amp 
              self.sine_theta = 0
              self.sine_step  = step
              self.K_base     = 0
              super( credit_sine, self ).__init__( **kwds )

          def advance( self ):
              self.sine_theta+= self.sine_step
          @property
          def K( self ):
              amp             = self.sine_amp * math.sin( self.sine_theta )
              return self.K_base + self.K_base * amp
          @K.setter
          def K( self, value ):
              self.K_base     = value

      # Create receipts with a credit.K fluctuating +/- .5%,  1 cycle per 6 hours
      #credit.advance          = lambda: None # if using credit_static...
      #credit.sine_amp         = 0
      credit                   = credit_sine( K=0.5, amp=.5/100,
                                       step=2 * math.pi / hosts_count / 6,
                                       prices=prices, basket=basket ) # Start w/ the global basket
      receipts                = []
      for _ in range( hours_count ):
          for h in hosts:
              receipts.append( h.receipt( dt=duration_hour ))
              credit.advance()

      items                   = [ [ rcpt[k] for k in credit.basket ] for cost,rcpt in receipts ]
      costs                   = [ cost for cost,rcpt in receipts ]

      regression              = linear_model.LinearRegression( fit_intercept=False, normalize=False )
      regression.fit( items, costs )
      select                  = { k: [ int( k == k2 ) for k2 in credit.basket ] for k in credit.basket }
      predict                 = { k: regression.predict( select[k] ) for k in credit.basket }

      actual_value            = credit.value()
      predict_value           = credit.value( prices=predict )
      [ [ "%dhr. x %d Hosts Cost" % ( hours_count, hosts_count ) ] + list( rcpt.keys() ),
        None,
        [ "%8.6f" % sum( cost for cost,rcpt in receipts ) ] \
        + [ "%8.6f" % sum( rcpt[k] for cost,rcpt in receipts ) for k in credit.basket ],
        None,
        [ "Score(R^2) %.9r" % ( regression.score( items, costs )) ],
        [ "Predicted" ] + [ "%5.2f" % predict[k] for k in credit.basket ],
        [ "Actual" ]    + [ "%5.2f" % current_prices[k] for k in credit.basket ],
        [ "Error" ]     + [ "%+5.3f%%" % (( predict[k] - current_prices[k] ) * 100 / current_prices[k] )
                            for k in credit.basket ],
        None,
        [ "Actual  Basket", "%5.2f" % actual_value ],
        [ "Predict Basket", "%5.2f" % predict_value ],
        [ "Error" , "%+5.3f%%" % (( predict_value - actual_value ) * 100 / actual_value ) ],
      ]

    #+END_SRC

    #+RESULTS:
    :RESULTS:
    | 24hr. x 3600 Hosts Cost |        holo |        net |        ram |      data |        cpu |
    |-------------------------+-------------+------------+------------+-----------+------------|
    | 22482.664667            | 5946.479350 | 117.878914 | 234.696838 | 59.027434 | 236.954237 |
    |-------------------------+-------------+------------+------------+-----------+------------|
    | Score(R^2) 0.9495018    |             |            |            |           |            |
    | Predicted               |        2.27 |      32.76 |       5.71 |     41.66 |       5.25 |
    | Actual                  |        2.03 |      38.22 |       4.75 |     39.36 |       4.49 |
    | Error                   |    +12.137% |   -14.292% |   +20.103% |   +5.844% |   +16.877% |
    |-------------------------+-------------+------------+------------+-----------+------------|
    | Actual  Basket          |       94.84 |            |            |           |            |
    | Predict Basket          |       94.62 |            |            |           |            |
    | Error                   |     -0.230% |            |            |           |            |
    :END:

    #+LATEX: }

    Lets see how well an hourly linear regression tracks the actual Basket price, in 10 minute
    intervals (so, 6 x 1-hour regression samples per hour).  Lets see if we can pick up the 1%
    sine-wave variation in Credit Factor K every 6 hours:

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :file images/receipts-regress-hourly.png :exports both
      # x is the fractional hour of the ends of each hour-long segment
      x_divs            = 6
      x                 = [ s / x_divs + 1 for s in range( hours_count * x_divs ) ]
      reg               = []
      act               = []
      for h in x: # Compute beg:end indices from fractional hour at end of each 1-hour range
          beg,end       = int( (h-1) * hosts_count ),int( h * hosts_count )
          items         = [ [ rcpt[k] for k in credit.basket ] for cost,rcpt in receipts[beg:end] ]
          costs         = [ cost                               for cost,rcpt in receipts[beg:end] ]
          regression.fit( items, costs )
          select        = { k: [ int( k == k2 ) for k2 in credit.basket ] for k in credit.basket }
          predict       = { k: regression.predict( select[k] ) for k in credit.basket }
          reg.append( credit.value( predict ))
          act.append( credit.value() )
      plt.plot( x, reg, label="Regress." )
      plt.plot( x, act, label="Actual" )
      plt.xlabel( "Hours" )
      plt.ylabel( "Holo Fuel" )
      plt.legend( loc="upper right" )
      plt.title( "Hourly Price Recovery w/ %5.2f%% K Variance" % ( credit.sine_amp * 100 ))
      plt.show()
    #+END_SRC

    #+RESULTS:
    [[file:images/receipts-regress-hourly.png]]

    #+LATEX: }

*** Simple Credit Feedback Control

    Finally, we have almost everything required to actually control the currency, using a simple PID controller.

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports both :results value raw drawer
      import time
      import sys
      import math
      if not hasattr( math, 'nan' ):
          math.nan            = float( 'nan' )

      timer                   = time.clock if sys.platform == 'win32' else time.time

      Kpid_t                  = collections.namedtuple( 'Kpid_t', ['Kp', 'Ki', 'Kd'] )
      Lout_t                  = collections.namedtuple( 'Lout_t', ['lo', 'hi'] )

      def clamp( val, lim ):
          """Return value if between range limits, otherwise the limit; math.nan indicates no limit"""
          if val < lim[0]:
              return lim[0]
          elif val > lim[1]:
              return lim[1]
          return val

      class controller( object ):
          """Simple PID loop with Integral anti-windup, bumpless transfer, and setpoint change damping."""
          def __init__( self, Kpid, setpoint=None, process=None, output=None,
                        Lout=( math.nan, math.nan ), now=None ):
              self.Kpid       = Kpid( 1, 1, 1 ) if Kpid is None else Kpid_t( *Kpid )
              self.Lout       = Lout_t( math.nan, math.nan ) if Lout is None else Lout_t( *Lout )
         
              self.setpoint   = setpoint or 0
              self.process    = process or 0
              self.output     = output or 0
         
              self.now        = now if now is not None else timer()
              self.P          = self.setpoint - self.process
              # Bumpless transfer; compute I required to maintain steady-state output
              self.I          = ( self.output - self.P * self.Kpid.Kp ) / self.Kpid.Ki if self.Kpid.Ki else 0
              self.D          = 0
         
          def loop( self, setpoint=None, process=None, now=None ):
              """Any change in setpoint? If our error (P - self.P) is increasing in a direction, and the
              setpoint moves in that direction, cancel that amount of the rate of change."""
              dS              = 0
              if setpoint is not None:
                  dS          = setpoint - self.setpoint
                  self.setpoint = setpoint
              if process is not None:
                  self.process = process
              if now is None:
                  now         = timer()
              if now > self.now: # No contribution if no +'ve dt!
                  dt          = now - self.now
                  self.now= now
                  P           = self.setpoint - self.process # Proportional: setpoint and process value error
                  I           = self.I + P * dt              # Integral:     total error under curve over time
                  D           = ( P - self.P - dS ) / dt     # Derivative:   rate of change of error (net dS)
                  self.output= ( P * self.Kpid.Kp + I * self.Kpid.Ki + D * self.Kpid.Kd )
                  self.P      = P
                  if not ( self.output < self.Lout.lo and I < self.I ) and \
                     not ( self.output > self.Lout.hi and I > self.I ):
                      self.I  = I                            # Integral anti-windup; ignore I if saturated
                  self.D      = D
              return self.value

          @property
          def value( self ):
              return clamp( self.output, self.Lout )
         
          def __repr__( self ):
             return "<%r: %+8.6f %s %+8.6f --> %+8.6f (%+8.6f) P: %+8.6f * %+8.6f, I: %+8.6f * %+8.6f, D: %+8.6f * %+8.6f>" % (
                 self.now, self.process,
                 '>' if self.process > self.setpoint else '<' if self.process > self.setpoint else '=',
                 self.setpoint, self.value, self.output,
                 self.P, self.Kpid.Kp, self.I, self.Kpid.Ki, self.D, self.Kpid.Kd )

      def near( a, b, significance = 1.0e-4 ):
          """ Returns True iff the difference between the values is within the factor 'significance' of
          one of the original values.  Default is to within 4 decimal places. """
          return abs( a - b ) <= significance * max( abs( a ), abs( b ))

      def nearprint( a, b, significance = 1.0e-4 ):
          if not near( a, b, significance ):
              print( "%r != %r w/in +/- x %r" % ( a, b, significance ))
              return False
          return True

      control             = controller( Kpid = ( 2.0, 1.0, 2.0 ), setpoint=1.0, process=1.0, now = 0. )
      assert near( control.loop( 1.0, 1.0, now = 1. ),   0.0000 )
      assert near( control.loop( 1.0, 1.0, now = 2. ),   0.0000 )
      assert near( control.loop( 1.0, 1.1, now = 3. ),  -0.5000 )
      assert near( control.loop( 1.0, 1.1, now = 4. ),  -0.4000 )
      assert near( control.loop( 1.0, 1.1, now = 5. ),  -0.5000 )
      assert near( control.loop( 1.0, 1.05,now = 6. ),  -0.3500 )
      assert near( control.loop( 1.0, 1.05,now = 7. ),  -0.5000 )
      assert near( control.loop( 1.0, 1.01,now = 8. ),  -0.3500 )
      assert near( control.loop( 1.0, 1.0, now = 9. ),  -0.3900 )
      assert near( control.loop( 1.0, 1.0, now =10. ),  -0.4100 )
      assert near( control.loop( 1.0, 1.0, now =11. ),  -0.4100 )

    #+END_SRC

    #+RESULTS:
    :RESULTS:
    :END:

    #+LATEX: }


    Lets implement a simple credit system that adjust K via the PID loop to move the price of the
    credit basket towards our target value.



* Holo Fuel Value Stabilization

  Price discovery gives us the tools we need to detect {in,de}flation as it occurs.  Control of
  liquid credit available in the marketplace gives us the levers we need to eliminate it.

  Traditional Fiat currencies control the issuance of liquidity by influencing the commercial banks
  to create more or less money through lending, and to increase/reduce liquidity through the net
  issuance/retirement of debt (which creates/destroys the principal money).

** Wealth Monetization

   In a wealth-backed currency, credit is created by the attachment of wealth to the monetary
   system, and credit lines of varying proportions being extended against the value of that wealth.

   Depending on savings rates, monetary velocity, public sentiment etc., the amount of credit
   available to actually be spent varies.  Since this available liquid credit is split between
   possible expenditures in priority order, the amount available to spend on each specific commodity
   therefore varies, driving the market price up and down.

   If reliable indicators of both the liquid credit supply within, and the quality and amount of
   wealth attached, exist within the system itself then control systems can be executed within the
   system to automatically control the monetization of wealth to achieve credit unit value
   equilibrium -- value-stability.

   Each reserve of wealth provided different flows and indicators, and can support value-stability
   in different ways.

*** Reserve Accounts

    The Reserve Accounts provide the interface between external currencies (eg. USD$, HOT ERC20
    Tokens) and Holo Fuel.

    Deposits to the reserve creates Holo Fuel credit limit (debt) at a current rate of exchange (TBD;
    eg. market rate + premium/discount).  The corresponding Holo Fuel credits created are deposited to
    the recipient's account.  
   
    If Holo Fuel inflation occurs within the system, credit must be withdrawn.  One way to
    accomplish this is to discourage creation of Holo Fuel (and encourage the redemption of Holo
    Fuel), by increasing the exchange rate.  The inverse (lowering exchange rate) would result in
    more Holo Fuel creation (less redemption), reducing the Holo Fuel available, and thus reduce
    deflation.

    The Reserve Accounts can respond very quickly, inducing Holo Hosts with Holo Fuel balances to
    quickly convert them out to other currencies when exchange rates rise.  Inversely, reducing
    rates would release waiting dApp owners to purchase more Holo Fuel for hosting their dApps, deploying
    it into the economy to address deflation (increasing computational commodity prices).
    
    A PD (Proportional Differential) control might be ideal for this.  This type of control responds
    quickly both to direct errors (things being the wrong price), but most importantly to changes in
    the 2nd derivative (changes in rate of rate of change); eg. things getting more/less expensive
    at an increasing rate.

    By eliminating the I (Integral) component of the PID loop, it does *not* slowly build up a
    systematic output bias; it simply adjusts the instantaneous premium/discount added to the
    current market exchange rate (eg. the HOT ERC20 market), to arrive at the Reserve Account
    exchange rate.  When inflation/deflation disappears, then the Reserve Account will have the same
    exchange rate as the market.

    Beginning with a set of reserves:

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports both :results value raw drawer

      reserve_t               = collections.namedtuple(
          'Reserve', [
              'rate',     # Exchange rate used for these funds
              'amount',   # The total value of the amount executed at .rate
           ] )            #   and the resultant credit in Holo Fuel == amount * rate

      reserve                 = {
          'EUR':          [],     # LIFO stack of reserves available
          'USD':          [ reserve_t( .0004, 200 ), reserve_t( .0005, 250 ) ], # 1,000,000 Holo Fuel
          'HOT ERC20':    [ reserve_t( 1, 1000000 ) ], # 1,000,000 Holo Fuel
      }

      def reserves( reserve ):
          return [ [ "Currency", "Rate avg.", "Reserves", "Holo Fuel Credits", ], None, ] \
                 + [ [ c, "%8.6f" % ( sum( r.amount * r.rate for r in reserve[c] )
                                     / ( sum( r.amount for r in reserve[c] ) or 1 ) ),
                       "%8.2f" % sum( r.amount for r in reserve[c] ),
                       "%8.2f" % sum( r.amount / r.rate for r in reserve[c] ) ]
                     for c in reserve ] \
                 + [ None,
                     [ '', '', '', sum( sum( r.amount / r.rate for r in reserve[c] ) for c in reserve ) ]]

      summary                 = reserves( reserve )
      summary # summary[-1][-1] is the total amount of reserves credit available, in Holo Fuel

    #+END_SRC

    #+RESULTS:
    :RESULTS:
    | Currency  | Rate avg. |   Reserves | Holo Fuel Credits |
    |-----------+-----------+------------+-------------------|
    | HOT ERC20 |  1.000000 | 1000000.00 |        1000000.00 |
    | USD       |  0.000456 |     450.00 |        1000000.00 |
    | EUR       |  0.000000 |       0.00 |              0.00 |
    |-----------+-----------+------------+-------------------|
    |           |           |            |         2000000.0 |
    :END:

    #+LATEX: }

    As a simple proxy for price stability, lets assume that we strive to maintain a certain stock of
    Holo Fuel credits in the system for it to be at equilibrium.  We'll randomly do exchanges of
    Holo Fuel out through exchanges at a randomly varying rate (also varied by the rate
    premium/discount), and purchases of Holo Fuel through exchanges at a rate proportional to the
    premium/discount.

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports both :results value raw drawer

      t_last                  = -1
      for t in range( 1000 ):
          dt                  = t - t_last
        
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    :END:

    #+LATEX: }
