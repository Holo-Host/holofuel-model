#+TITLE: Holo Fuel Model
#+STARTUP: org-startup-with-inline-images inlineimages
#+OPTIONS: ^:nil # Disable sub/superscripting with bare _; _{...} still works
#+LATEX_HEADER: \usepackage[margin=1.0in]{geometry}
* Holo Fuel

  A value-stable wealth-backed cryptocurrency platform, where each unit is defined in terms of a
  basked of computational resources, operating in a powerful decentralized verification environment.

   #+BEGIN_SRC ditaa :file images/holofuel-overview.png :cache yes :cmdline -r -S -o

       +-----------------------------------------+
       v                                         |
   +--------+               +--------+           | 
   |        |               |        |           | 
   |        |-+  Something  | PID    | Whatever  |
   |        +-|------------>|        |-----------+
   +--------+ |  X Mbps     +--------+  Y Mbps    
     |        |                                   
     +--------+                                   
       account


   #+END_SRC

   #+RESULTS[4bc4e7ce2ec98c14f78e17fcb3d22255e1a196d5]:
   [[file:images/holofuel-overview.png]]

** The Computational Resources Basket

   One Holo Fuel (HOT) is defined as being able to purchase 1 month of Holo Hosting services for the
   front-end (ie. web API) portion of a typical dApp:

   #+LATEX: {\scriptsize
   #+BEGIN_SRC ipython :session :exports results :results value
   %matplotlib inline
   from __future__ import absolute_import, print_function, division
   try:
       from future_builtins import zip, map # Use Python 3 "lazy" zip, map
   except ImportError:
       pass
   import matplotlib.pyplot as plt
   import numpy        # .random, ...
   from sklearn import linear_model
   import math
   import collections

   commodity_t         = collections.namedtuple(
       'Commodity', [
           'units',
           'quality',
           'notes',
       ] )
   commodities         = {
       'holo':         commodity_t( "Host",    "",           "Inclusion in the Holo system" ),
       'cpu':          commodity_t( "Core",    "Median",     "A processing core" ),
       'ram':          commodity_t( "GB",      "Median",     "Processor memory" ),
       'net':          commodity_t( "TB",      "Median",     "Internet bandwidth" ),
       'data':         commodity_t( "TB",      "Median",     "Persistent storage (DHT/DB/file)" ),
   }
   trade_t             = collections.namedtuple(
       'Trade', [ 
           'security', 
           'price', 
           'time', 
           'amount', 
           'agent',
         ] )
   # The basket represents the computational resource needs of a typical Holochain dApp's "interface"
   # Zome.  A small dual-core Holo Host (ie. on a home Internet connection) could perhaps expect to run
   # 5 of these; a quad-core / 8-thread perhaps 20.
   basket            = {
       # Commodity     Amount
       'holo':        1.0 , # Host
       'cpu':          .25, # Core
       'ram':          .25, # GB
       'net':          .1 , # TB
       'data':         .1 , # TB
   }
   # Produces the org-mode table from result 2d list
   [ ["Amount", "Units", "Commodity", "Description"],
     None ] \
 + [ [ "%5.2f" % basket[k], commodities[k].units, k, commodities[k].notes ]
     for k in basket ]
   #+END_SRC
   #+LATEX: }

   #+RESULTS:
   | Amount | Units | Commodity | Description                      |
   |--------+-------+-----------+----------------------------------|
   |   1.00 | Host  | holo      | Inclusion in the Holo system     |
   |   0.10 | TB    | net       | Internet bandwidth               |
   |   0.25 | GB    | ram       | Processor memory                 |
   |   0.10 | TB    | data      | Persistent storage (DHT/DB/file) |
   |   0.25 | Core  | cpu       | A processing core                |

   This might be roughly equivalent to the 2018 price of (and actual utilization of) a small cloud
   hosting node (eg. a $5/month Droplet on Digital Ocean), with a premium for inclusion in the Holo
   system.

*** Holo Hosting Premium

    A Holochain Distributed Application (dApp) hosted on Holo provides a valuable set of features,
    over and above simply hosting a typical web application on a set of cloud servers.  

    - [ ] Reliability. Few single points of failure.
    - [ ] Backup. All DHT data is spread across many nodes.
    - [ ] Scalability.  Automatically scales to absorb increased load.

    The value of Holo is substantial in terms of real costs to traditional app developers, and is a
    component of the basket of commodities defining the price of Holo Fuel.  However, it's real
    monetary value will emerge over time, as the developer community comprehends it.  Our pricing
    algoritm must be able to dig this Holo premium component out of the historical hosting prices,
    as a separate component.

*** Resource Price Stability

    There are many detailed requirements for each of these commodities, which may be required for
    certain Holochain applications; CPU flags (eg. AVX-512, cache size, ...), RAM (GB/s bandwidth),
    HDD (time to first byte, random/sequential I/O bandwidth), Internet (bandwidth/latency to
    various Internet backbone routers). 

    The relative distribution of these features will change over time; RAM becomes faster, CPU cores
    more powerful. The definition of a typical unit of these commodities therefore changes; as
    Moore's law decreases the price, the specifications of the typical computer also improve,
    counterbalancing this inflationary trend.

    For each metric, the price of service on the median Holo Host node will be used; 1/2 will be
    below (weaker, priced at a discount), 1/2 above (more powerful, priced at a premium).  This will
    nullify the natural inflationary nature of Holo Fuel, if we simply defined it in terms of fixed
    2018 computational resources.

** Commodity Price Discovery

   Value stabilization requires knowledge of the current prices of each commodity in the currency's
   valuation basket, ideally denominated in the currency itself.  If these commodities are traded
   within the cryptocurrency implementation, then we can directly discover them on a distributed
   basis.  If outside commodity prices are used, then each independent actor computing the control
   loop must either reach consensus on the price history (as collected from external sources, such
   as Distributed Oracles), or trust a separate module to do so. In Holo Fuel, we host the sale of
   Holo Host services to dApp owners, so we know the historical prices.

   When a history of Holo Hosting service prices is available, Linear Regression can be used to
   discover the average fixed (Holo Hosting premium) and variable (CPU, ...) component costs
   included in the prices, and therefore the current commodity basket price.
   
*** Recovering Commodity Basket Costs

    To illustrate price recovery, lets begin with simulated prices of a basket of commodities:

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports both :results value raw
    # To simulate initial pricing, lets start with an estimate of proportion of basket value represented
    # by each amount of the basket's commodities.  Keep it simple; all are roughly equally weighted.
    price_mean          = 1.00                  # target price: 1.00 Holo Fuel == 1 basket
    price_sigma         = price_mean / 10       #  difference allowed; about +/- 10% of target
    prices              = { k: ( price_sigma * numpy.random.randn() + price_mean ) / len( basket ) / basket[k]
                          for k in basket }
    [ [ "Commodity", "HOT$", "Per" ],
      None ] \
    + [ [ k, "%5.2f" % ( prices[k] ), "%s / mo." % ( commodities[k].units ) ]
        for k in basket ]
    #+END_SRC
    #+LATEX: }

    #+RESULTS:
    | Commodity | HOT$ | Per        |
    |-----------+------+------------|
    | holo      | 0.18 | Host / mo. |
    | net       | 1.84 | TB / mo.   |
    | ram       | 0.95 | GB / mo.   |
    | data      | 2.36 | TB / mo.   |
    | cpu       | 0.85 | Core / mo. |

    From this set of current commodity prices, we can compute the current price of the HOT currency's basket:

    #+BEGIN_SRC ipython :session :exports results :results value raw
    [ [ "HOT$ Basket Price" ],
      None,
      [ "$%5.2f" % ( sum( basket[k] * prices[k] for k in basket )) ] ]
    #+END_SRC

    #+RESULTS:
    | HOT$ Basket Price |
    |-------------------|
    | $ 1.05            |

    Once we have the currency's underlying commodity basket, lets simulate a sequence of trades of
    various amounts of these commodities.  We will not know the exact costs of each commodity used
    to compute the price, or how much is the baseline Holo system premium.

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports both :results value raw
    amounts_mean	= 1.00
    amounts_sigma	= 0.50
    error_sigma		= 0.10 # +/- 10% variance in bids (error) vs. price
    trades		= []
    number		= 10000
    for _ in range( number ):
        amounts		= { k: 1 if k == 'holo' else max( 0, basket[k] * ( amounts_sigma * numpy.random.randn() + amounts_mean )) for k in basket }
        price		= sum( amounts[k] * prices[k] for k in amounts )
        error		= price * error_sigma * numpy.random.randn()
        bid		= price + error
        trades.append( dict( bid = bid, price = price, error = error, amounts = amounts ))

    [ [ "HOT$","calc/err", "dApp Requirements" ], None ] \
    + [ [ 
          "%5.2f" % t['bid'],
          "%5.2f%+5.2f" % ( t['price'], t['error'] ),
           ", ".join( "%5.4f %s %s" % ( v * basket[k], k, commodities[k].units ) for k,v in t['amounts'].items() ),
        ]
        for t in trades[:5] ]
    #+END_SRC
    #+LATEX: }

    #+RESULTS:
    | HOT$ |  calc/err | dApp Requirements                                                               |
    |------+-----------+---------------------------------------------------------------------------------|
    | 0.82 | 0.88-0.06 | 1.0000 holo Host, 0.0084 net TB, 0.0021 ram GB, 0.0115 data TB, 0.0772 cpu Core |
    | 0.71 | 0.73-0.02 | 1.0000 holo Host, 0.0075 net TB, 0.0631 ram GB, 0.0036 data TB, 0.0251 cpu Core |
    | 0.99 | 1.02-0.03 | 1.0000 holo Host, 0.0048 net TB, 0.0902 ram GB, 0.0013 data TB, 0.1103 cpu Core |
    | 0.99 | 1.01-0.01 | 1.0000 holo Host, 0.0142 net TB, 0.0416 ram GB, 0.0034 data TB, 0.0955 cpu Core |
    | 1.52 | 1.45+0.07 | 1.0000 holo Host, 0.0229 net TB, 0.0671 ram GB, 0.0146 data TB, 0.0723 cpu Core |


    Lets see if we can recover the approximate Holo baseline and per-commodity costs from a sequence
    of trades.  Create some trades of 1 x Holo + random amounts of commodities around the
    requirements of a typical Holo dApp, adjusted by a random amount (ie. 'holo' always equals 1
    unit, so that all non-varying remainder is ascribed to the "baseline" Holo Hosting premium).

    Compute a linear regression over the trades, to try to recover an estimate of the prices.

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports both :results value
    items		= [ [ t['amounts'][k] for k in basket ] for t in trades ]
    bids		= [ t['bid'] for t in trades ]
    regression		= linear_model.LinearRegression( fit_intercept=False, normalize=False )
    regression.fit( items, bids )
    select		= { k: [ int( k == k2 ) for k2 in basket ] for k in basket }
    predict		= { k: regression.predict( select[k] ) for k in basket }

    #   + """\
    #: Score(R^2): %r
    #"""  % ( regression.score( items, bids ) ) 
    [ [ "Commodity",  "Predicted", "Actual", "Error",
       # "selected"
      ],
      None ] \
    + [ [ k, 
          "%5.2f" % ( predict[k] ),
          "%5.2f" % ( prices[k] ),
          "%+5.3f%%" % (( predict[k] - prices[k] ) * 100 / prices[k] ),
          # select[k]
        ]
        for k in basket ]

    #+END_SRC
    #+LATEX: }

    #+RESULTS:
    | Commodity | Predicted | Actual |   Error |
    |-----------+-----------+--------+---------|
    | holo      |      0.18 |   0.18 | -1.606% |
    | net       |      1.83 |   1.84 | -0.260% |
    | ram       |      0.94 |   0.95 | -0.077% |
    | data      |      2.37 |   2.36 | +0.391% |
    | cpu       |      0.87 |   0.85 | +1.200% |


    Finally, we can estimate the current HOT$ basket price from the recovered commodity prices:

    #+BEGIN_SRC ipython :session :exports results :results value raw
    basket_price	= sum( basket[k] * prices[k]  for k in basket )
    basket_predict	= sum( basket[k] * predict[k] for k in basket )
    [ [ "HOT$ Basket Price", "Error" ], None,
      [ "$%5.2f" % basket_predict,
        "%+5.3f%%" % (( basket_predict - basket_price ) * 100 / basket_price ),
        ]]
    #+END_SRC

    #+RESULTS:
    | HOT$ Basket Price |   Error |
    |-------------------+---------|
    | $ 1.05            | -0.008% |

    We should be able to recover the underlying commodity prices, and hence the basket price within
    a high degree of certainty, even in the face of relatively large differences in the mix of
    prices paid for hosting.
