#+TITLE: Holo Fuel Model
#+STARTUP: org-startup-with-inline-images inlineimages
#+OPTIONS: ^:nil # Disable sub/superscripting with bare _; _{...} still works
#+LATEX_HEADER: \usepackage[margin=1.0in]{geometry}
* Holo Fuel Valuation

  A value-stable wealth-backed cryptocurrency platform, where each unit is defined in terms of a
  basked of computational resources, operating in a powerful decentralized verification environment.

   #+BEGIN_SRC ditaa :file images/holofuel-overview.png :cache yes :cmdline -r -S -o

       +-----------------------------------------+
       v                                         |
   +--------+               +--------+           | 
   |        |               |        |           | 
   |        |-+  Something  | PID    | Whatever  |
   |        +-|------------>|        |-----------+
   +--------+ |  X Mbps     +--------+  Y Mbps    
     |        |                                   
     +--------+                                   
       account


   #+END_SRC

   #+RESULTS[4bc4e7ce2ec98c14f78e17fcb3d22255e1a196d5]:
   [[file:images/holofuel-overview.png]]

** The Computational Resources Basket

   One Holo Fuel (HOT) is defined as being able to purchase 1 month of Holo Hosting services for the
   front-end (ie. web API, databases, etc.) portion of a typical dApp.

   This might be roughly equivalent to the 2018 price of (and actual utilization of) a small cloud
   hosting setup (eg. several $5/month Droplet on Digital Ocean at partial utilization hosting
   front-ends, DBs, backups, etc.), plus ancillary hosting services (represented by a premium for
   inclusion in the Holo system).

   If the minimal Hosting costs for a small Web app is estimated at USD$100/mo., and comprises 5
   cloud hosting nodes and anciliary services for the various aspects of the system.  An equivalent
   Holo Host based system would have similar CPU and storage requirements overall, but a greater
   redundancy (say, 5 x, so all DHTs spread across 25 Holo Hosts).

   Thus, the basket of commodities defining the value of USD$100 == HOT$100 could be defined as:

   #+LATEX: {\scriptsize
   #+BEGIN_SRC ipython :session :exports results :results value
%matplotlib inline
from __future__ import absolute_import, print_function, division
try:
    from future_builtins import zip, map # Use Python 3 "lazy" zip, map
except ImportError:
       pass
import matplotlib.pyplot as plt
import numpy        # .random, ...
from sklearn import linear_model
import math
import collections

commodity_t             = collections.namedtuple(
    'Commodity', [
        'units',
        'quality',
        'notes',
    ] )
commodities             = {
    'holo':         commodity_t( "Host",    "",           "Inclusion in the Holo system" ),
    'cpu':          commodity_t( "Core",    "Median",     "A processing core" ),
    'ram':          commodity_t( "GB",      "Median",     "Processor memory" ),
    'net':          commodity_t( "TB",      "Median",     "Internet bandwidth" ),
    'data':         commodity_t( "TB",      "Median",     "Persistent storage (DHT/DB/file)" ),
}

# The basket represents the computational resource needs of a typical Holochain dApp's "interface"
# Zome.  A small dual-core Holo Host (ie. on a home Internet connection) could perhaps expect to
# run 100 HOT worth of these at 50% CPU utilization, 1TB of bandwidth; a quad-core / 8-thread
# perhaps 500 HOT worth at ~60% CPU utilization.

iron_count              =   5                   # Real iron req'd to host tradition small App
holo_fanout             =   5                   #   and additional Holo fan-out for DHT redundancy, etc.
hosts                   = iron_count * holo_fanout
basket_value            = 100.0                 # 1 HOT$ =~= 1 USD$; USD$100 of cloud hosting per minimal dApp, typ.
basket                  = {
    # Commodity     Amount, Proportion
    'holo':        hosts,           # Holo Host system fan-out and value premium
    'cpu':          1.00,           # Cores, avg. utilization across all iron
    'ram':          1.00,           # GB,    ''
    'net':          0.50,           # TB,    '' 
    'data':         0.25,           # TB,    ''
}

# In the wild, prices will fluctuate according to supply/demand and money supply dynamics.  We'll
# start with some artificial weights.
weight                  = {
    'holo':         60/100,
    'cpu':          5/100,
    'ram':          5/100,
    'net':         20/100,
    'data':        10/100,
}             

# Produces the org-mode table from result 2d list
[ ["Commodity", "Amount", "Units", "Weight", "Description"],
  None ] \
+ [ [ k, "%5.2f" % basket[k], commodities[k].units, "%5.3f%%" % ( weight[k] * 100 ), commodities[k].notes ]
    for k in basket ]
   #+END_SRC

   #+RESULTS:
   | Commodity | Amount | Units |  Weight | Description                      |
   |-----------+--------+-------+---------+----------------------------------|
   | holo      |  25.00 | Host  | 60.000% | Inclusion in the Holo system     |
   | net       |   0.50 | TB    | 20.000% | Internet bandwidth               |
   | ram       |   1.00 | GB    |  5.000% | Processor memory                 |
   | data      |   0.25 | TB    | 10.000% | Persistent storage (DHT/DB/file) |
   | cpu       |   1.00 | Core  |  5.000% | A processing core                |

   #+LATEX: }

*** Holo Hosting Premium

    A Holochain Distributed Application (dApp) hosted on Holo provides a valuable set of features,
    over and above simply hosting a typical web application on a set of cloud servers.  These
    services must usually be either purchased, or architected by hand and distributed across
    multiple cloud hosting nodes for redundancy.

    - [ ] Reliability. Few single points of failure.
    - [ ] Backup. All DHT data is spread across many nodes.
    - [ ] Scalability.  Automatically scales to absorb increased load.

    The value of Holo is substantial in terms of real costs to traditional app developers, and is a
    component of the basket of commodities defining the price of Holo Fuel.  However, it's real
    monetary value will emerge over time, as the developer community comprehends it.  Our pricing
    algoritm must be able to dig this Holo premium component out of the historical hosting prices,
    as a separate component.

*** Resource Price Stability

    There are many detailed requirements for each of these commodities, which may be required for
    certain Holochain applications; CPU flags (eg. AVX-512, cache size, ...), RAM (GB/s bandwidth),
    HDD (time to first byte, random/sequential I/O bandwidth), Internet (bandwidth/latency to
    various Internet backbone routers). 

    The relative distribution of these features will change over time; RAM becomes faster, CPU cores
    more powerful. The definition of a typical unit of these commodities therefore changes; as
    Moore's law decreases the price, the specifications of the typical computer also improve,
    counterbalancing this inflationary trend.

    For each metric, the price of service on the median Holo Host node will be used; 1/2 will be
    below (weaker, priced at a discount), 1/2 above (more powerful, priced at a premium).  This will
    nullify the natural inflationary nature of Holo Fuel, if we simply defined it in terms of fixed
    2018 computational resources.

** Commodity Price Discovery

   Value stabilization requires knowledge of the current prices of each commodity in the currency's
   valuation basket, ideally denominated in the currency itself.  If these commodities are traded
   within the cryptocurrency implementation, then we can directly discover them on a distributed
   basis.  If outside commodity prices are used, then each independent actor computing the control
   loop must either reach consensus on the price history (as collected from external sources, such
   as Distributed Oracles), or trust a separate module to do so. In Holo Fuel, we host the sale of
   Holo Host services to dApp owners, so we know the historical prices.

   When a history of Holo Hosting service prices is available, Linear Regression can be used to
   discover the average fixed (Holo Hosting premium) and variable (CPU, ...) component costs
   included in the prices, and therefore the current commodity basket price.
   
*** Recovering Commodity Basket Costs

   To illustrate price recovery, lets begin with simulated prices of a basket of commodities.  A
   prototypical minimal dApp owner could select HOT$100 of these resources, eg. 25x holo Hosts, .05
   TB data, 1.5 cpu, etc. as appropriate for their specific application's needs.

   This wouldn't actually be a manual procedure; testing would indicate the kind of loads to expect
   for a given amount and type of user activity, and a calculator would estimate the various
   resource utilization and costs. At run time, the credit extended to the dApp owner (calculated
   from prior history of Hosting receipt payments) would set the maximum outstanding Hosting
   receipts allowed; the dApp deployment would auto-scale out to Hosts as required; candidate Hosts
   would auto-install the application as it reached its limits of of various resource utilization
   across its current stable of Hosts, hoping to generate Hosting receipts.

   #+LATEX: {\scriptsize
   #+BEGIN_SRC ipython :session :exports both :results value raw
def rnd_sd( sigma, mean=0 ):
    return sigma * numpy.random.randn() + mean

# To simulate initial pricing, lets start with an estimate of proportion of basket value represented
# by each amount of the basket's commodities.  Prices of each of these commodities is free to float
# in a real market, but we'll start with some pre-determined "weights"; indicating that the amount
# of the specified commodity holds a greater or lesser proportion of the basket's value.
# Regardless, HOT$100 Holo Fuel is guaranteed to buy the entire basket.
prices                  = {}
for k in basket:
      price_mean        = basket_value * weight[k] / basket[k] # target price: 1.00 Holo Fuel == 1 basket / basket_value
      price_sigma       = price_mean / 10       #  difference allowed; about +/- 10% of target
      prices[k]         = rnd_sd( price_sigma, price_mean )

[ [ "Commodity", "HOT$", "Per", "Per" ],
      None ] \
+ [ [ k, "%5.2f" % ( prices[k] ), commodities[k].units, 'mo.' ]
    for k in basket ]
    #+END_SRC

    #+RESULTS:
    | Commodity |  HOT$ | Per  | Per |
    |-----------+-------+------+-----|
    | holo      |  2.55 | Host | mo. |
    | net       | 40.36 | TB   | mo. |
    | ram       |  4.68 | GB   | mo. |
    | data      | 37.97 | TB   | mo. |
    | cpu       |  5.14 | Core | mo. |

    #+LATEX: }

    From this set of current assumed commodity prices, we can compute the current price of the HOT
    currency's basket:

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports results :results value raw
[ [ "HOT$ Basket Price" ],
  None,
  [ "$%5.2f / %.2f" % ( sum( basket[k] * prices[k] for k in basket ), basket_value ) ] ]
   #+END_SRC

   #+RESULTS:
   | HOT$ Basket Price |
   |-------------------|
   | $103.18 / 100.00  |

   #+LATEX: }

    If the current price of this basket is >100, then we are experiencing commodity price inflation;
    if <100, price deflation.  Feedback control loops will act to bring the price back to HOT$100
    per basket.

*** Holo Hosting Receipts 

    Once we have the currency's underlying commodity basket, lets simulate a sequence of trades of
    various amounts of these commodities.  In the Holo system, this is represented by Hosts issuing
    receipts for services to dApp owners.

    Each Hosting receipt will be for a single Holo Host, not for the entire dApp; the sum of all
    Holo Hosting receipts issued to the dApp owner for our archetypical small dApp would sum to
    approximately HOT$100 Holo Fuel per month.

    We will not know the exact costs of each commodity used to compute the price, or how much is the
    baseline Holo system premium.  However, it will be dependant on the capability of the Host
    (stronger hosts can charge more, for hosting more specialized dApps), and the amount of various
    services used.

    So, lets issue a bunch of small Holo Hosting receipts, each for approximately 1/25th of the
    total Holo Hosting load (since our small dApp is spread across 25 Holo Hosts).

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports both :results value raw

amounts_mean            = 1.00
amounts_sigma           = 0.5
error_sigma             = 0.10 # +/- 10% variance in bids (error) vs. price
trades                  = []
number                  = 10000
for _ in range( number ):
    # Each dApp consumes a random standard distribution of the target amount of each commodity
    amounts             = { k: 1 if k == 'holo'
                               else max( 0, basket[k] * rnd_sd( amounts_sigma, amounts_mean ) / basket['holo'] )
                            for k in basket }
    price               = sum( amounts[k] * prices[k] for k in amounts )
    error               = price * error_sigma * numpy.random.randn()
    bid                 = price + error
    trades.append( dict( bid = bid, price = price, error = error, amounts = amounts ))

[ [ "HOT$","calc/err", "dApp Requirements" ], None ] \
+ [ [ 
      "%5.2f" % t['bid'],
      "%5.2f%+5.2f" % ( t['price'], t['error'] ),
       ", ".join( "%5.4f %s %s" % ( v, k, commodities[k].units ) for k,v in t['amounts'].items() ),
    ]
    for t in trades[:5] ] \
+ [ [ '...' ] ]

    #+END_SRC

    #+RESULTS:
    | HOT$ |  calc/err | dApp Requirements                                                               |
    |------+-----------+---------------------------------------------------------------------------------|
    | 4.18 | 4.17+0.01 | 1.0000 holo Host, 0.0151 net TB, 0.0193 ram GB, 0.0163 data TB, 0.0468 cpu Core |
    | 3.42 | 3.07+0.35 | 1.0000 holo Host, 0.0052 net TB, 0.0141 ram GB, 0.0005 data TB, 0.0372 cpu Core |
    | 4.57 | 4.86-0.29 | 1.0000 holo Host, 0.0365 net TB, 0.0305 ram GB, 0.0083 data TB, 0.0605 cpu Core |
    | 4.06 | 4.58-0.52 | 1.0000 holo Host, 0.0359 net TB, 0.0506 ram GB, 0.0038 data TB, 0.0241 cpu Core |
    | 3.01 | 3.50-0.49 | 1.0000 holo Host, 0.0045 net TB, 0.0482 ram GB, 0.0076 data TB, 0.0377 cpu Core |
    |  ... |           |                                                                                 |
    #+LATEX: }

*** Recovery of Commodity Valuations

    Lets see if we can recover the approximate Holo baseline and per-commodity costs from a sequence
    of trades.  Create some trades of 1 x Holo + random amounts of commodities around the
    requirements of a typical Holo dApp, adjusted by a random amount (ie. 'holo' always equals 1
    unit, so that all non-varying remainder is ascribed to the "baseline" Holo Hosting premium).

    Compute a linear regression over the trades, to try to recover an estimate of the prices.

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports both :results value

items			= [ [ t['amounts'][k] for k in basket ] for t in trades ]
bids			= [ t['bid'] for t in trades ]

regression		= linear_model.LinearRegression( fit_intercept=False, normalize=False )
regression.fit( items, bids )
select			= { k: [ int( k == k2 ) for k2 in basket ] for k in basket }
predict			= { k: regression.predict( select[k] ) for k in basket }

[ [ "Score(R^2): ", "%.9r" % ( regression.score( items, bids )), '', '' ],
  None ] \
+ [ [ "Commodity",  "Predicted", "Actual", "Error",
      # "selected"
  ],
  None ] \
+ [ [ k, 
      "%5.2f" % ( predict[k] ),
      "%5.2f" % ( prices[k] ),
      "%+5.3f%%" % (( predict[k] - prices[k] ) * 100 / prices[k] ),
      #select[k]
    ]
    for k in basket ]

    #+END_SRC

    #+RESULTS:
    | Score(R^2): | 0.5534794 |        |         |
    |-------------+-----------+--------+---------|
    | Commodity   | Predicted | Actual |   Error |
    |-------------+-----------+--------+---------|
    | holo        |      2.55 |   2.57 | -0.488% |
    | net         |     40.45 |  40.84 | -0.955% |
    | ram         |      5.53 |   5.25 | +5.447% |
    | data        |     39.37 |  39.34 | +0.072% |
    | cpu         |      5.39 |   5.28 | +2.031% |

    #+LATEX: }

*** Commodity Basket Valuation

    Finally, we can estimate the current HOT$ basket price from the recovered commodity prices.

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports results :results value raw

basket_price		= sum( basket[k] * prices[k]   for k in basket )
basket_predict		= sum( basket[k] * predict[k]  for k in basket )
[ [ "HOT$ Price Recovered", "vs. Actual", "Error" ], None,
  [ "$%5.2f / %.2f" % ( basket_predict, basket_value ), 
    "%5.2f" % ( basket_price ), 
    "%+5.3f%%" % (( basket_predict - basket_price ) * 100 / basket_price ),
    ]]

    #+END_SRC

    #+RESULTS:
    | HOT$ Price Recovered | vs. Actual |   Error |
    |----------------------+------------+---------|
    | $98.13 / 100.00      |      98.19 | -0.065% |

    #+LATEX: }

    We have shown that we should be able to recover the underlying commodity prices, and hence the
    basket price with a high degree of certainty, even in the face of relatively large differences
    in the mix of prices paid for hosting.

* Holo Fuel Value Stabilization

  Price discovery gives us the tools we need to detect {in,de}flation as it occurs.  Control of
  credit available in the marketplace gives us the levers we need to eliminate it.

** Wealth Monetization

   In a wealth-backed currency, credit is created by the attachment of wealth to the monetary
   system.  Depending on savings rates, monetary velocity, public sentiment etc., the amount of
   credit available to be spent varies.  Since this available credit is split between possible
   expenditures in priority order, the amount available to spend on each specific commodity
   therefore varies, driving the market price up and down.

*** Reserve Accounts

    The Reserve Accounts provide the interface between external currencies (eg. USD$, HOT ERC20
    tokens) and HOT$ Holo Fuel.

    Deposits to the reserve creates HOT$ credit limit (debt) at a current rate of exchange (TBD;
    eg. market rate + premium/discount).  The corresponding HOT$ credits created are deposited to
    the recipients HOT$ account.  
   
    If HOT$ inflation occurs within the system, credit must be withdrawn.  One way to accomplish
    this is to discourage creation of HOT$ (and encourage the redemption of HOT$ ), by increasing the
    exchange rate.  The inverse (lowering exchange rate) would result in more HOT$ creating (less
    redemption), reducing the HOT$ available, and thus reduce deflation.

    The Reserve Accounts can respond very quickly, inducing Holo Hosts with HOT$ balances to quickly
    convert them out to other currencies when exchange rates rise.  Inversely, reducing rates would
    release waiting dApp owners to purchase more HOT$ for hosting their dApps, deploying it into the
    economy to address deflation (increasing computational commodity prices).
    
    A PD (Proportional Differential) control might be ideal for this.  This type of control responds
    quickly both to direct errors (things being the wrong price), but most importantly to changes in
    the 2nd derivative (changes in rate of rate of change); eg. things getting more/less expensive
    at an increasing rate.

    By eliminating the I (Integral) component of the PID loop, it does *not* slowly build up a
    systematic output bias; it simply adjusts the instantaneous premium/discount added to the
    current market exchange rate (eg. the HOT ERC20 market), to arrive at the Reserve Account
    exchange rate.  When inflation/deflation disappears, then the Reserve Account will have the same
    exchange rate as the market.

    Beginning with a set of reserves:

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports results :results value

reserve_t               = collections.namedtuple(
    'Reserve', [
        'rate',     # Exchange rate used for these funds
        'amount',   # The total value of the amount executed at .rate
     ] )            #   and the resultant credit in Holo Fuel == amount * rate

reserve                 = {
    'EUR':          [],     # LIFO stack of reserves available
    'USD':          [ reserve_t( .0004, 200 ), reserve_t( .0005, 250 ) ], # 1,000,000 Holo Fuel
    'HOT ERC20':    [ reserve_t( 1, 1000000 ) ], # 1,000,000 Holo Fuel
}

def reserves( reserve ):
    return [ [ "Currency", "Rate avg.", "Reserves", "Holo Fuel Credits", ], None, ] \
           + [ [ c, "%8.6f" % ( sum( r.amount * r.rate for r in reserve[c] )
                               / ( sum( r.amount for r in reserve[c] ) or 1 ) ),
                 "%8.2f" % sum( r.amount for r in reserve[c] ),
                 "%8.2f" % sum( r.amount / r.rate for r in reserve[c] ) ]
               for c in reserve ] \
           + [ None,
               [ '', '', '', sum( sum( r.amount / r.rate for r in reserve[c] ) for c in reserve ) ]]

summary                 = reserves( reserve )
summary # summary[-1][-1] is the total amount of reserves credit available, in Holo Fuel

    #+END_SRC

    #+RESULTS:
    | Currency  | Rate avg. |   Reserves | Holo Fuel Credits |
    |-----------+-----------+------------+-------------------|
    | HOT ERC20 |  1.000000 | 1000000.00 |        1000000.00 |
    | USD       |  0.000456 |     450.00 |        1000000.00 |
    | EUR       |  0.000000 |       0.00 |              0.00 |
    |-----------+-----------+------------+-------------------|
    |           |           |            |         2000000.0 |

    #+LATEX: }

    As a simple proxy for price stability, lets assume that we strive to maintain a certain stock of
    Holo Fuel credits in the system for it to be at equilibrium.  We'll randomly do exchanges of
    Holo Fuel out through exchanges at a randomly varying rate (also varied by the rate
    premium/discount), and purchases of Holo Fuel through exchanges at a rate proportional to the
    premium/discount.

    #+LATEX: {\scriptsize
    #+BEGIN_SRC ipython :session :exports both :results value

t_last                  = -1
for t in range( 1000 ):
    dt                  = t - t_last
        
    #+END_SRC
    #+LATEX: }

    #+RESULTS:
